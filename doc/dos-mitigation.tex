% Created 2016-01-29 Fri 11:01
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\date{\today}
\title{DoS Mitigation in (n+1)sec protocol}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.5.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\tableofcontents

\section{DoS axioms:}
\label{sec-1}
\begin{itemize}
\item we assume that the joiner cannot deny access for other joiners for the following:
\end{itemize}
\subsection{The line in the code which result in dropping other join requests:}
\label{sec-1-1}
   if (action$_{\text{to}}$$_{\text{take}}$.action$_{\text{type}}$ \texttt{= RoomAction::NEW\_PRIORITY\_SESSION ||
            action\_to\_take.action\_type =} RoomAction::PRESUME$_{\text{HEIR}}$) \{
    stale$_{\text{in}}$$_{\text{limbo}}$$_{\text{sessions}}$$_{\text{presume}}$$_{\text{heir}}$(action$_{\text{to}}$$_{\text{take}}$.bred$_{\text{session}}$->session$_{\text{id}}$);
\} // else \{ //user state in the room

\subsection{The condition that lead to PRESUME$_{\text{HEIR}}$}
\label{sec-1-2}
if (everybody$_{\text{authenticated}}$$_{\text{and}}$$_{\text{contributed}}$()) \{
    group$_{\text{dec}}$();
    // first compute the confirmation
    compute$_{\text{session}}$$_{\text{confirmation}}$();
    // we need our future ephemeral key to attach to the message
    future$_{\text{cryptic}}$.init();
    // now send the confirmation message
    Message outboundmessage(\&cryptic);

outboundmessage.create$_{\text{session}}$$_{\text{confirmation}}$$_{\text{msg}}$(
    session$_{\text{id}}$, hash$_{\text{to}}$$_{\text{string}}$$_{\text{buff}}$(session$_{\text{confirmation}}$),
    public$_{\text{key}}$$_{\text{to}}$$_{\text{stringbuff}}$(future$_{\text{cryptic}}$.get$_{\text{ephemeral}}$$_{\text{pub}}$$_{\text{key}}$()));

outboundmessage.send(room$_{\text{name}}$, us);

RoomAction re$_{\text{limbo}}$$_{\text{action}}$;

re$_{\text{limbo}}$$_{\text{action}}$.action$_{\text{type}}$ = RoomAction::PRESUME$_{\text{HEIR}}$;
re$_{\text{limbo}}$$_{\text{action}}$.bred$_{\text{session}}$ = this;

    return StateAndAction(GROUP$_{\text{KEY}}$$_{\text{GENERATED}}$, re$_{\text{limbo}}$$_{\text{action}}$);
    \emph{/ if we are joing we don't need to relimbo and the room will
    /} ignore the action,
\}

\subsection{The condition that lead to NEW$_{\text{PRIORITY}}$$_{\text{SESSION}}$}
\label{sec-1-3}
RoomAction Session::shrink(std::string leaving$_{\text{nick}}$)
\{
 \emph{/ we are basically running the intention to leave message
 /} without broadcasting it (because it is not us who intend to do so)
 // make a fake intention to leave message but don't send ack
 RoomAction new$_{\text{session}}$$_{\text{action}}$;

auto leaver = participants.find(leaving$_{\text{nick}}$);
if (leaver == participants.end()) \{
    logger.warn("participant " + leaving$_{\text{nick}}$ + " is not part of the active session of the room " + room$_{\text{name}}$ +
                " from which they are trying to leave, already parted?");
\} else if (zombies.find(leaving$_{\text{nick}}$) != zombies.end()) \{ // we haven already shrunk and made a session
    logger.debug("shrunk session for leaving user " + leaving$_{\text{nick}}$ + " has already been generated. nothing to do",
                 \uline{\uline{FUNCTION}}, myself.nickname);
\} else \{ \emph{/ shrink now
    /} if everything is ok add the leaver to the zombie list and make a
    // session without zombies
    zombies.insert(*leaver);

// raison$_{\text{detre}}$.insert(RaisonDEtre(LEAVE, leaver->id));

Session* new$_{\text{child}}$$_{\text{session}}$ =
    new Session(PEER, us, room$_{\text{name}}$, \&future$_{\text{cryptic}}$, future$_{\text{participants}}$());

new$_{\text{session}}$$_{\text{action}}$.action$_{\text{type}}$ = RoomAction::NEW$_{\text{PRIORITY}}$$_{\text{SESSION}}$;
new$_{\text{session}}$$_{\text{action}}$.bred$_{\text{session}}$ = new$_{\text{child}}$$_{\text{session}}$;

    \emph{/ we are as we have farewelled
    /} my$_{\text{state}}$ = FAREWELLED; \emph{/We shouldn't change here and it is not clear why we
    /} we need this stage, not to accept join? why? join will fail by non confirmation
    // of the leavers
    return new$_{\text{session}}$$_{\text{action}}$;
\}

    return c$_{\text{no}}$$_{\text{room}}$$_{\text{action}}$;
\}

\subsection{The joiner DOSing}
\label{sec-1-4}
\begin{itemize}
\item As the result, the joiner can not leave the session before joining so it can't
invoke NEW$_{\text{PRIORITY}}$$_{\text{SESSION}}$. 
\begin{itemize}
\item PRESUME$_{\text{HEIR}}$ is only called when group$_{\text{dec}}$ is successful: If the group dec is not correct then the user will not drop the other sessions.
\item If the joiner send correct message to some users and bad message to others, it can force some of participant to drop the session and some not. Therefore, whenever a user is dropping a session, they should announce it if it is because of 
\begin{itemize}
\item timeout
\item auth error
\item decryption error.
\item confirmation error.

\item If any user send decryption error or confirmation error then all users of the session runs the cheater detection algorithm.
\end{itemize}

\item Badly signed messages are considered just garbage/not sent/not received.

\item Scenarios:
\begin{itemize}
\item Malicious joiner sends bad shares.
\item Results in decryption error. Still need investigation because it could be some insider who did it. Other joiners joins as they did before.
\item Some decrypt correctly some decrypt badly. In this situation we still run a dos detection process. if the shares are all signed then it is on the sender.
\end{itemize}

\item Dropping by timing:
\begin{itemize}
\item You request drop when grace period + wait period passed.
\item You accept drop if the grace period has passed.
\item If you received the message of the party being dropped you keep them. Drop the 
dropper.
\end{itemize}

\item Detection
\begin{enumerate}
\item If it fails do to session confirmation or decryption failure, the user should inform and request for reseassion marked with dos detection.
\item If it passes the second time then you can go ahead, take off the dos tag.
\item If it fails and tag with dos detection. Everybody sign and send their new private key with their old ephemeral public key and old established p2p keys.
\item Detect the cheater. drop the cheater. broadcast your proof.
\item If someone is dropping someone else without proper proof, drop them with sending the proof.
\end{enumerate}

\item Remedy:
\begin{enumerate}
\item You drop the session with the cheaters/dosers if it is past presume heir, you send a new participant info message for the new message which tells other joiners to try again.
\item You drop as many as you need till you are alone.
\item When you drop someone you don't accept them as participants anymore only as joiners.
\item Somebody wants to join as participant but you expect them as joiner, you inform them that.
\end{enumerate}
\end{itemize}
\end{itemize}

\subsection{No joiner is receiving priority before}
\label{sec-1-5}
**

\section{List of DoS possibilities}
\label{sec-2}
DoS Maliciousness
\begin{itemize}
\item Unresponsiveness.
\item Generating wrong keyshare.
\item Confirming wrong session.
\item Asking for people to leave without reason.

\item When a participant conclude that a participant is malicious
bceause of one of above reasons it request a leave for that 
participant.
\end{itemize}

\section{How to detect}
\label{sec-3}
\begin{itemize}
\item How to detect DoS:
\begin{itemize}
\item Time dependent: allow double amount of timeout to re-act but accept any re-action after the timeout period.
\item Generating wrong keyshare:
\begin{itemize}
\item AES-GCM the shares sends it out to everybody.
\item 
\end{itemize}
\end{itemize}
\end{itemize}

\section{How to react after detection}
\label{sec-4}
\begin{itemize}
\item If DoS happens during a join process, 
Is it the joiner malicious:
   The maliciousness is happening in session confirmation phase:
\begin{itemize}
\item just drop the session in limbo. Send re-join message with participant info without DoSer.
\item The maliciousness is happening before sending session confirmation phase. Just drop the joining session.
\end{itemize}
A current participant is malicious:
\begin{itemize}
\item run a leave request which generate a session confirmation which helps the joiner.
\end{itemize}

\item If DoS happens during leave process:
Run a leave on the malicious participant.

\item If DoS happens during re-session.
Run a leave on the malicious participant.

\item Authentication failure is a reason for barring join but not DoS.

\item When someone get kicked out due to DoS reason he should be put on 
last person to join after all joiners already in line.
\end{itemize}

\section{Concerns:}
\label{sec-5}
Timing problems. There should be acceptable delay. The messages arrived during 
acceptable delay period should be ordered in their hash order. But for now we 
assume global ordering on messages for now.

\section{Proof of DoS protection}
\label{sec-6}
\begin{itemize}
\item Theorem: Suppose $U_1,...,U_n$ are set of participant. $I_o \cap I_m = \{1,...,n\}$.
\end{itemize}
then after running above algorithm, each participants get a list of $plist_i$. If
the transport is honestly delivering messages in timely manner then for $i,j \in I_o$ 
we have $U_i \in plist_j$.

With enough round of running algorithm an honest joiner $U_i \in I_o$.

\section{New Algorithm:}
\label{sec-7}
\begin{itemize}
\item Badly signed messages dropped treated as undelivered.
\item If someone fails to contribute any message we are waiting for the grace$_{\text{period}}$
    we just assume they left.
\item If key generation or confirmation fails then we need to resession with the session
\end{itemize}
tagged as DoS detection. You only can do that by sharing the evidence of cheating.
\begin{itemize}
\item If we fail key generation or confirmation with Dos detection tag, then we publish
all private key encrypted by p2p keys signed by non-dos tagged authenticated
private key. The cheater will be detected and kicked out.
\item If someone kick someone out (that's staring session S while U$_{\text{i}}$ is not in the 
new session) without signed leave request by U$_{\text{i}}$ then U$_{\text{j}}$ start a session without
U$_{\text{i}}$ in it but U$_{\text{j}}$ in it. That could be because we didn't leave request
\end{itemize}


-- Current users start a timer as soon as they get a join request for 
   all users in the room to response with authentication. 

Note: Authentication faille should be an acceptable response.

-- If the timer time out. They mark the user as unresponsive, they start
   another timer to report the user as unresponsive.

-- If they receive the message before the timer time out.
   and no other users requests the user to leave they continue with
   the session establishment.

-- If somebody request new session without the user they accept
   the request and can drop the session.

-- If they don't receive message before the second timer time
   out they request a session without the unresponsive users.

-- If they receive  a session shrink but the kicked out user
   has replied in time of the first timer. They drop the requesting
   user. (should we?)

The users will play the second round. setup timers and follow the same 
rules.

-- Conflict of circles:
   Obviously there will be circle conflict because:

A thinks B is in and C is not. (A,B) => A eventually doesn't receive a response from B and drops B
B thinks C is in and A is not. (B,C) =>  B doesn't receive a response from C and drop C
C thinks A,B and C are in. (A,B,C) => doesn't receive a response from A and B and drop both of them.

----
So it is obvious that we should treat cheating and transport problems totally 
separately. Therefore we call provable cheating 

In particular if A decide that C is unresponsive while C is responsive then
B can relay C info signed by C to A.

----
The protocol general rule:

-- If key recovery or confirmation failed. Rekey try again, if it fails then publish 
keys, publish proof of cheating. start a new session with the cheater out.

-- If someone failed to reply. Send the failed replied after grace period. Other participant
either should send the same message or rebroadcast the failed message. When 
you get the message for failed delivery. You \textbf{have to} agree or rebroadcast, if
you fail to do so you'll be drop as well.

The failed message, has the share for the new subgroup, finally the responsive 
parties will make a successful subgroup.

So we break the protocol into sections:

Delivery failure/Transport delay recovery.

\begin{itemize}
\item The protocol agrees on INTERACTIVE$_{\text{GRACE}}$$_{\text{PERIOD}}$.
\item If U$_{\text{i}}$ expect a message from U$_{\text{j}}$ to establish session and it does not receive it in INTERACTIVE$_{\text{GRACE}}$$_{\text{PERIOD}}$ as of end of last round. then U$_{\text{i}}$ start new$_{\text{session}}$(kick$_{\text{out}}$ U$_{\text{i}}$, reason: U$_{\text{i}}$ fails message type x from session sid).
\item If U$_{\text{k}}$ receive a kick out message, either they have received the failed delivery message or not: yes, they resend the message to s'id, message type x from sid by U$_{\text{j}}$ (encrypt or not?) and does not follow up with the new
session.
\item If U$_{\text{i}}$ is the only member of the session and there are more participant in the room U$_{\text{i}}$ will rejoin the room.
\end{itemize}

Cheater detection protocol:

If the key fails to recover or the session confirmation do not match, then a special session with new ephemeral key will be distributed and session establishment will be tried. If the cheater detection session fails 
at the same stages then the participants will reveal their private key signed by their old key, the cheater will be detected and kicked out.

\begin{itemize}
\item U$_{\text{i}}$ fails at key recovery or conf$_{\text{j}}$!= conf$_{\text{i}}$. Request a cheater detection session, with reason. (reason is the set of signed shares which does not satisfies the system or the confirmation which does not matches the deduced key)
\item U$_{\text{j}}$ receive a request for cheater detection evaluate the reason. If it is legitimate, starts a cheater detection session.
\item If the cheater detection succeed, it become the main session.
\item If the cheater detection session fails. publish private keys signed by old private keys.
\item Detect cheater and kicked them out with proof.
\end{itemize}
% Emacs 24.5.1 (Org mode 8.2.10)
\end{document}
