\documentclass{article}

\title{(n+1)sec protocol specification}
\author{eQualit.ie}

\setlength{\parskip}{1em}
\setlength{\parindent}{0em}

\def\message#1{\texttt{#1}}
\def\field#1{\textit{#1}}

\def\smfield#1{\textsf{#1}}


\newenvironment{basicmessage}[2]{
\newcommand{\messagefield}[2]{
\field{##1} & \textsf{##2} \\
\hline
}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\message{#1} [#2]} \\
\hline
\hline
}{
\end{tabular}
}

\newenvironment{conversationmessage}[2]{
\newcommand{\messagefield}[2]{
& \field{##1} & \textsf{##2} \\
\hline
}
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{\message{#1} [#2]} \\
\hline
\hline
\field{conversation-public-key} & \multicolumn{2}{l|}{\textsf{publickey}} \\
\hline
\field{conversation-signature} & \multicolumn{2}{l|}{\textsf{signature}} \\
\hline
\field{conversation-message-body} & \multicolumn{2}{l|}{} \\
\hline
}{
\end{tabular}
}






\begin{document}

\maketitle

\section{Introduction}
\label{sec:introduction}

The (n+1)sec system is a protocol for end-to-end encrypted and authenticated textual group chat communications.
It aims to provide a platform and paradigm for synchronous text chat similar to those used in commonly used chat systems such as IRC \cite{irc} and Jabber multi user conversations \cite{jabber}, augmented with the cryptographic tools to guarantee communication security without relying on any third parties for these security assurances.

The (n+1)sec system, in conscious imitation of the celebrated off-the-record or \emph{OTR} chat cryptography framework \cite{otr}, 
% layered on top of a chat network

% this is a protocol spec

% status: draft

% reference implementation

% sections: 2, 3, other



\section{Protocol Overview}
\label{sec:protocol-overview}

The (n+1)sec system is a protocol through which users of text chat systems, such as IRC \cite{irc} or Jabber multi-user-chat \cite{jabber}, can hold cryptographically secured multi-party text chat sessions.
Using an approach similar to OTR \cite{otr}, (n+1)sec clients exchange encoded text messages via a general-purpose group chat room, such as an IRC channel or a Jabber multi-user chat room, and thereby construct end-to-end encrypted chat sessions that use the general-purpose chat room as a carrier.

Chat sessions in (n+1)sec make use of end-to-end encryption to ensure the security of chat communications, even when the chat session is held in a public or otherwise presumed-insecure chat room.
This cryptography is used to authenticate the identity of the members of the chat session, as well as to encrypt the chat communications in such a way that only the members of a chat session have access to the chat contents.

Chat in (n+1)sec takes place in so-called \emph{conversations}.
An (n+1)sec Conversation is a chat session, behaviorally similar to IRC channels and the like, that exists as a distributed agreement between a group of people in a carrier chat room to talk to each other, and whose communication takes place via (n+1)sec messages exchanged in a single carrier chat room.
A Conversation at any point has a set of \emph{participants}, which is part of the state of a Conversation that all participants agree on at any point.
The different Participants in a Conversation have all authenticated each other's identities, as identified by a public key, and ---some caveats notwithstanding--- chat messages in a Conversation are encrypted in such a way that only its constituent Participants can decrypt.

All communications related to a Conversation are necessarily accompanied by a cryptographic signature based on the public key of the sender.
Furthermore, all chat messages in a Conversation ---making up the payload of that Conversation--- are encrypted using a symmetric cryptographic key negotiated between, and known only by, the Conversation's Participants.
This symmetric key is negotiated each time the list of Participants of a Conversation changes (that is, each time a Participant either joins or leaves the Conversation), as well as at regular intervals to reduce the risk of any particular key being compromised.

\subsection{Rooms}
The (n+1)sec protocol makes use of 

Section~\ref{sec:carrier-chatrooms}

% the np1sec protocol uses chatrooms as a transport infrastructure.
% by exchanging np1sec messages in a given chatroom of some description, np1sec clients can engage in encrypted communications with other np1sec clients in that same room.
% within certain limitations, np1sec can work on top of arbitrary text chat systems; the details are in Section~\ref{sec:carrier-chatrooms}.

% when entering a room, an np1sec client sends a message announcing their presence as an np1sec-capabel client.
% as part of this announcement, the client announces a public key, and requests other np1sec clients in the room to identify themselves.
% when this happens, the new signup and the old client engage in a mutual authentication protocol, after which they are (hopefully) both assured of each other's identity.







% np1sec sends messages to rooms. some messages deal with the presence of a user in a room; others are directed at specific conversations and contain metadata about the conversations they apply to.

\subsection{Conversations}
This includes the description of how ephemeral public keys are used to identify conversation participants.


\subsection{Conversation state machine}
on a protocol level, np1sec conversations are represented by state machines represented identically across all clients that take part in the conversation. The np1sec protocol specifies in detail how messages and chat events are to affect this idealized state machine, which implementations need to follow to the letter to stay compatible.


\subsection{Joining a conversation}


\subsection{Events}
Merge into state machine?


\subsection{Key agreement}


\subsection{Chat messages}








\section{Chat Model}
\label{sec:chat-model}

maybe we can skip this?



%what np1sec does
%how np1sec works from an API / UI point of view

% conversation in een carrier room
% participants, invitees, people who can be invited
% authentication, public keys
% messages, event ordering
% votekicks, conversation title?
% cryptographic assurances



\section{Carrier Chatrooms}
\label{sec:carrier-chatrooms}
exact carrier chatroom model

carrier limitations (based on high level API)

invitable user list


\section{Cryptography}
\label{sec:cryptography}
triple diffie hellman deniable authentication

key exchange protocol

signatures?

choice of primitives -- elliptic curves, sha256, aes-gcm


\section{The Conversation State Machine}

%=== introduction to the state machine model ===
%why do we use a state machine model?
%upsides and downsides

%=== participants ===

%=== state machine hash ===
%NOT: the details of how this hash is computed

%=== events ===

%=== key exchanges ===
%including: latest session id

%=== joining ===
%importing a state machine


Terminology:

member: user whose nickname exists in a the state machine

four stages of membership:

unidentified invitee: member without conversation pubkey

unauthenticated identified invitee: member with conversation pubkey but no authentication flag

authenticated invitee: member with conversation pubkey that has been sponsored by a participant

participant: member who has fully joined, can participate in key negotiations, can invite others



\section{Messages}
list of messages

describes for each message the semantics of the message; the time it may/must be sent; and in a declarative css-style way, the effect of a conversation packet on the conversation state machine

conversation hash computation

rules on what packets apply to what conversations?

\subsection{Message structure}

opcode / sender / payload struct

\subsection{Encoding}

tons of icky details here

\subsection{Room messages}

Room messages are (n+1)sec messages that do not address any particular conversations.
They are used to announce a client as being (n+1)sec capable; to announce a client's cryptographic identity in the form of a public key; and for different (n+1)sec clients in a room to confirm each other's identities.

\subsubsection{QUIT}
\label{sec:messages/quit}

The \message{QUIT} (= 0x01) message causes the sender to effectively leave the room as far as the (n+1)sec protocol is concerned.
A user that sent a \message{QUIT} message is considered in the same state as a user who has not announced (n+1)sec capability; the user has thus left the room from the point of view of the (n+1)sec abstraction, even if the user has not left the carrier chat room.

\begin{basicmessage}{QUIT}{0x01}
\messagefield{cookie}{nonce}
\end{basicmessage}

A \message{QUIT} message declares the \field{sender} to have effectively left the (n+1)sec room.
An implementation should handle it in the same way as the user leaving the carrier chat room.

When receiving a \message{QUIT} message, the client SHOULD retract all cryptographic identities of the \field{sender}, the same way it would do if the \field{sender} were to leave the carrier chat room instead.
The client MUST remove the \field{sender} from all conversations of which they are a member, the same way as if the \field{sender} had left the carrier chat room instead, as described in Section~\ref{todo:conversation-state-machine/left-room}.

The \field{cookie} field carries no significance for clients receiving a \message{QUIT} message and should be ignored.
The field is included to allow an implementation to recognize when it receives its own \message{QUIT} message, and thus leave the (n+1)sec room in a predictable state when connecting to a carrier chat room in which they are already present.


\subsubsection{HELLO}
\label{sec:messages/hello}

The \message{HELLO} (= 0x02) message announces the sender's (n+1)sec capability, as well as their cryptographic identity.
It is sent either by a client when it enters a room to announce its presence to other (n+1)sec users in the room, or in reply to such a message by existing users in the room to announce their presence to the newcomer.

\begin{basicmessage}{HELLO}{0x02}
\messagefield{long-term-public-key}{publickey}
\messagefield{room-public-key}{publickey}
\messagefield{solicit-replies}{boolean}
\end{basicmessage}

A \message{HELLO} message sent to a room by a user \field{sender} indicates that \field{sender} is an (n+1)sec-capable chat client, claiming to possess the private key corresponding to \field{long-term-public-key}.
Based on this declaration, the user receiving the \message{HELLO} message is able to invite the \field{sender} to any current and future conversations, using the announced \field{long-term-public-key}.

A \message{HELLO} message sent by a particular user only indicates that this user \emph{claims} to possess the private key corresponding to the \field{long-term-public-key}.
A client can confirm this cryptographic identity by performing an authentication process, as described in Section~\ref{todo:cryptography/authentication}, using the \field{room-public-key} as the \field{sender}'s ephemeral public key for authentication purposes.
This authentication process is implemented using the \message{ROOM\_AUTHENTICATION\_REQUEST} and \message{ROOM\_AUTHENTICATION} messages.
A client SHOULD NOT trust the authenticity of the \field{sender}'s identity without having successfully completed such an authentication process, and ---from a user interface perspective--- should probably avoid depicting the \field{sender} to hold \field{long-term-public-key} in any way until the authentication process is successfully completed.

To avoid attacks in which a malicious user could waste unlimited resources by sending a large amount of \message{HELLO} messages claiming different identities, an implementation MAY limit the amount of active invitable identities for a particular \field{sender} to 1, or limit it based on some other characteristic.
If so, a \message{HELLO} message claiming an identity the implementation does not currently consider active MAY be interpreted by the implementation as an implicit retraction of any earlier claimed identities by this \field{sender}.
If an implementation does interpret a \message{HELLO} message as a retraction of earlier identities in this way, it may only retract these identities for the sake of representing the visible users in the room, as described in Section~\ref{sec:carrier-chatrooms}.
In particular, the \message{HELLO} message MUST NOT have any effect on any conversations of which the \field{sender} is a member.

The \field{solicit-replies} flag, if set, indicates that the sender requests all (n+1)sec-capable clients in the room to identify itself; this is generally the case after a user has just joined a room, and wants to be able to invite the people in it to conversations.
If this flag is set, any clients that wish to identify themselves can reply with a \message{HELLO} message of their own, repeating their already-established identity to the new user.
However, to avoid bandwidth amplification attacks, implementations SHOULD avoid replying to a message with \field{solicit-replies} set from a \field{sender} to which it has already identified itself.
To avoid infinite sequences of \message{HELLO} replies, a reply message to a message with \field{solicit-replies} set MUST NOT itself have \field{solicit-replies} set.


\subsubsection{ROOM\_AUTHENTICATION\_REQUEST}
\label{sec:messages/room-authentication-request}

The \message{ROOM\_AUTHENTICATION\_REQUEST} (= 0x03) message is used to request a client to authenticate itself based on the cryptographic identity announced in an earlier \message{HELLO} message.
It contains the authentication challenge that forms the base of this authentication process.

\begin{basicmessage}{ROOM\_AUTHENTICATION\_REQUEST}{0x03}
\messagefield{my-long-term-public-key}{publickey}
\messagefield{my-room-public-key}{publickey}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\messagefield{room-public-key}{publickey}
\messagefield{authentication-nonce}{nonce}
\end{basicmessage}

A \message{ROOM\_AUTHENTICATION\_REQUEST} message is a request to the client that uses the identity consisting of the (\field{username}, \field{long-term-public-key}, \field{room-public-key}) triple to authenticate itself to the user using the (\field{sender}, \field{my-long-term-public-key}, \field{my-room-public-key}) identity.
It declares that \field{sender} will consider \field{username} authenticated for this identity after receiving a valid authentication confirmation for this pair of identities, described in Section~\ref{todo:cryptography/authentication}, using \field{authentication-nonce} as the authentication nonce.

A \message{ROOM\_AUTHENTICATION\_REQUEST} message is addressed to the user with username \field{username} and private keys matching the \field{long-term-public-key} and \field{room-public-key}.
Any client that does not have this complete identity ---including clients that use this username but use different keys--- SHOULD ignore the message.
The client that does have this identity, if any, can authenticate itself to the \field{sender} by sending a \message{ROOM\_AUTHENTICATION} message containing the authentication confirmation described above.


\subsubsection{ROOM\_AUTHENTICATION}
\label{sec:messages/room-authentication}

The \message{ROOM\_AUTHENTICATION} (= 0x04) message provides confirmation of a cryptographic identity to a single recipient.
Assuming the authentication confirmation is valid, this allows the recipient to confirm that the sender holds the private keys they claimed to possess in a \message{HELLO} message.

\begin{basicmessage}{ROOM\_AUTHENTICATION}{0x04}
\messagefield{my-long-term-public-key}{publickey}
\messagefield{my-room-public-key}{publickey}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\messagefield{room-public-key}{publickey}
\messagefield{authentication-confirmation}{authentication-token}
\end{basicmessage}

A \message{ROOM\_AUTHENTICATION} message is a confirmation to the client using the identity consisting of the (\field{username}, \field{long-term-public-key}, \field{room-public-key}) triple that the \field{sender} holds the private keys corresponding to \field{my-long-term-public-key} and \field{my-room-public-key}.
The \emph{authentication-confirmation} should contain the authentication token described in Section~\ref{todo:cryptography/authentication}; if it does, this proves that the sender does indeed hold these private keys.

A \message{ROOM\_AUTHENTICATION} message is addressed to the user with username \field{username} and private keys matching the \field{long-term-public-key} and \field{room-public-key}.
Any client that does not have this complete identity ---including clients that use this username but use different keys--- SHOULD ignore the message.
The client that does have this identity, if any, should consider the authentication valid if and only if
\begin{itemize}
\item that client previously sent a \message{ROOM\_AUTHENTICATION\_REQUEST} to the user with identity (\field{username}, \field{long-term-public-key}, \field{room-public-key}), and
\item the \field{authentication-confirmation} field equals the expected authentication token computed from the \field{authentication-nonce} sent in the accompanying \message{ROOM\_AUTHENTICATION\_REQUEST} message, as specified in Section~\ref{todo:cryptography/authentication}.
\end{itemize}
If both requirements hold, this proves that the \field{sender} holds the private key corresponding to \field{my-long-term-public-key}.


\subsection{Conversation messages}
\label{sec:messages/conversation-messages}

The majority of messages in (n+1)sec are addressed to, and relevant for, a particular conversation.
These \emph{conversation messages} contain information addressing the recipient conversation, and affect only the status of that specific conversation.
Conversation messages have a shared structure expressing the relation between messages and conversations, and are handled in a similar way.

\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{Conversation message general structure} \\
\hline
\hline
\field{conversation-public-key} & \textsf{publickey} \\
\hline
\field{message-signature} & \textsf{signature} \\
\hline
\field{message-body} & \textsf{octet-stream} \\
\hline
\end{tabular}

Conversation messages are sent by the identified members of a particular conversation, and addressed to all members of that conversation.
To denote the conversation to which a conversation message is addressed, conversation messages carry a \field{conversation-public-key} field, which contains the conversation public key of the identified conversation member that sent the message.
The conversation addressed by a conversation message, then, is that conversation (if any) that contains an identified member with username \field{sender} and conversation public key \field{conversation-public-key}.
Conversation messages also carry a \field{message-signature}, which is a signature of the message-specific body of the message signed using the private key corresponding to \field{conversation-public-key}.

The members of a conversation, as described in Section~\ref{todo:conversation-state-machine}, share a representation of the abstract \emph{conversation state machine} that defines the state of the conversation.
Coordination between members of a conversation relies on the different members maintaining consensus about the exact state of this state machine; if members of a conversation somehow come to disagree about the state of this state machine, the conversation can no longer be maintained, as described in Section~\ref{todo:conversation-state-machine/inconsistency}.
It is therefore critical that different members of a conversation process conversation messages in such a way that the abstract conversation state machine is affected in precisely identical ways between their clients.

This section specifies for each conversation message what effect the message has on the abstract conversation state machine of each conversation to which it applies.
In order to not break compatibility, implementation MUST implement these specifications to the letter.
Some aspects of a client's state for a particular conversation, such as the determination of which other members are authenticated, are not contained in the conversation state machine; for those topics, the specification has a force limited to a behavior that the client SHOULD implement.

Conversation messages contain a signature of the message body, which is used to verify authenticity of messages sent by conversation members.
This signature is computed as a cryptographic signature of the message's \field{message-body} octet stream, as described in Section~\ref{todo:cryptography/signatures}, using the private key corresponding to the message's \field{conversation-public-key}.
On receiving any converstaion message, clients should verify this signature, by confirming that the message's \field{message-signature} is a valid signature of the message's \field{message-body} for the \field{conversation-public-key}.
If this signature is not valid, implementations MUST NOT modify the conversation state machine of any conversations.
Implementations SHOULD ignore messages with invalid signatures entirely, though they MAY raise some form of impersonation warning instead.

If a conversation message has a valid signature matching its \field{conversation-public-key}, the message is addressed to any conversations, existing in the carrier chat room in which the message was sent, that contain an identified member with username \field{sender} and conversation public key \field{conversation-public-key}.
Conversations matching these conditions are said to be \emph{addressed by} the conversation message.
On receiving a conversation message with a valid signature, implementations MUST NOT modify the conversation state machine of any conversations that are not addressed by the message.
Implementations MUST modify the conversation state machine of any conversations addressed by the message for which the implementation is maintaining a representation, by implementing the rules specified below.

There is one exception that applies to this specification of conversations addressed by conversation messages.
The \message{INVITE\_ACCEPTANCE} message, described in Section~\ref{sec:messages/invite-acceptance}, is used by unidentified members of a conversation to upgrade their status to an identified member, and is addressed to and processed by certain conversations beyond those that include the \field{sender} as an identified member.
These \message{INVITE\_ACCEPTANCE} messages carry a \field{message-signature} signed based on its \field{conversation-public-key} as normal, but are addressed to a larger collection of conversations.
The details of this anomaly are specified in Section~\ref{sec:messages/invite-acceptance}.

When an implementation receives a conversation message with a valid signature addressed to one or more conversations of which the implementation is maintaining a representation, the implementation must digest the message into those conversations' \smfield{status hash}, as described in Section~\ref{todo:conversation-state-machine/hash}.
For each of those conversations to which the message is addressed, the implementation must then perform the message-specific processing specified in the remainder of this section.

\subsubsection{Event messages}

\subsubsection{INVITE}

The \message{INVITE} (= 0x11) message is sent by a conversation participant to invite a new user to the conversation, identified by a (username, long term public key) pair.
An \message{INVITE} message informs the invited user of the existence of the conversation, and allows the invited user to start tracking the status of the conversation.

\begin{conversationmessage}{INVITE}{0x11}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\end{conversationmessage}

An \message{INVITE} message 


\subsubsection{CONVERSATION\_STATUS}

\begin{conversationmessage}{CONVERSATION\_STATUS}{0x12}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\messagefield{conversation-state-machine}{state-machine}
\end{conversationmessage}

\subsubsection{CONVERSATION\_CONFIRMATION}

\begin{conversationmessage}{CONVERSATION\_CONFIRMATION}{0x13}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\messagefield{conversation-status-hash}{hash}
\end{conversationmessage}

\subsubsection{INVITE\_ACCEPTANCE}
\label{sec:messages/invite-acceptance}

\begin{conversationmessage}{INVITE\_ACCEPTANCE}{0x14}
\messagefield{my-long-term-public-key}{publickey}
\messagefield{inviter-username}{string}
\messagefield{inviter-long-term-public-key}{publickey}
\messagefield{inviter-conversation-public-key}{publickey}
\end{conversationmessage}

Addressed-conversation exception documentation here.

\subsubsection{CONVERSATION\_AUTHENTICATION\_REQUEST}

The \message{CONVERSATION\_AUTHENTICATION\_REQUEST} (= 0x15) message is used to request a conversation member to authenticate itself for the cryptographic identity consisting of its long term public key and conversation public key.
It is the in-conversation analogue of the \message{ROOM\_AUTHENTICATION\_REQUEST} message.
It contains the authentication challenge that forms the base of this authentication process.

\begin{conversationmessage}{CONVERSATION\_AUTHENTICATION\_REQUEST}{0x15}
\messagefield{username}{string}
\messagefield{authentication-nonce}{nonce}
\end{conversationmessage}

A \message{CONVERSATION\_AUTHENTICATION\_REQUEST} message is a request to the identified member \field{username} to authenticate itself to the \field{sender}, for \field{username}'s and \field{sender}'s long term public keys and conversation public keys described by the conversation state machine.
It declares that \field{sender} will consider \field{username} authenticated for this identity after receiving a valid authentication confirmation for this pair of identities, described in Section~\ref{todo:cryptography/authentication}, using \field{authentication-nonce} as the authentication nonce.
The \field{username} identified member, upon receiving a \message{CONVERSATION\_AUTHENTICATION\_REQUEST} message, can authenticate itself to the \field{sender} by sending a \message{CONVERSATION\_AUTHENTICATION} message containing this authentication confirmation.

The \message{CONVERSATION\_AUTHENTICATION\_REQUEST} message has no effect on the conversation state machine besides the \smfield{status hash}.

\subsubsection{CONVERSATION\_AUTHENTICATION}

The \message{CONVERSATION\_AUTHENTICATION} (= 0x16) message provides confirmation of a cryptographic identity to a member of a conversation.
It is the in-conversation analogue of the \message{ROOM\_AUTHENTICATION} message.
Assuming the authentication confirmation is valid, this allows the recipient member to confirm that the sender holds the private keys corresponding to their public keys described by the conversation state machine.

\begin{conversationmessage}{CONVERSATION\_AUTHENTICATION}{0x16}
\messagefield{username}{string}
\messagefield{authentication-confirmation}{authentication-token}
\end{conversationmessage}

TODO: This, and the above message, probably needs to be formalized.






\subsubsection{AUTHENTICATE\_INVITE}

The \message{AUTHENTICATE\_INVITE} (= 0x17) message is sent by a conversation participant to promote an identified, unauthenticated invitee to an authenticated invitee.
Afterwards, the authenticated invitee is able to join the conversation as a participant.

\begin{conversationmessage}{AUTHENTICATE\_INVITE}{0x17}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\messagefield{conversation-public-key}{publickey}
\end{conversationmessage}

An \message{AUTHENTICATE\_INVITE} message indicates that the \field{sender} has confirmed that the member \field{username} holds the identity consisting of the (\field{username}, \field{long-term-public-key}, \field{conversation-public-key}) triple, and that \field{sender} is willing to allow this user entrance into the conversation.
Once this allowance has been granted, the invited member is able to join the conversation with a \message{JOIN} message.

If a conversation contains an unauthenticated identified invitee invited by a certain participant, that participant SHOULD send an \message{AUTHENTICATE\_INVITE} message after receiving a \message{CONVERSATION\_AUTHENTICATION} message that successfully confirms the identity of the invitee.
Any other participants may also send such an \message{AUTHENTICATE\_INVITE} message, and thereby become the inviter of the invited member.

If the conversation state machine addressed by an \message{AUTHENTICATE\_INVITE} message contains an unauthenticated identified member with identity triple (\field{username}, \field{long-term-public-key}, \field{conversation-public-key}), and the \field{sender} is a participant of the conversation, then the unauthenticated member gets promoted to an authenticated member.
The newly-authenticated member's inviter becomes the message's \field{sender}.
If not, the \message{AUTHENTICATE\_INVITE} message has no effect on the conversation state machine besides the \smfield{status hash}.

\subsubsection{CANCEL\_INVITE}

The \message{CANCEL\_INVITE} (= 0x18) message is sent by a conversation participant to retract any invitations for a given (username, long term public key) pair.

\begin{conversationmessage}{CANCEL\_INVITE}{0x18}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\end{conversationmessage}

A \message{CANCEL\_INVITE} message indicates that the \field{sender} wants to retract an active invitation for a given user.
If no active invitations for the described member exist, or the member described by the \message{CANCEL\_INVITE} message has since become a participant of the conversation, the message has no effect.

A \message{CANCEL\_INVITE} message removes from the conversation state machine any invited members ---be they unidentified invitees, unauthenticated identified invitees, or authenticated invitees--- with username \field{username}, long term public key \field{long-term-public-key}, and inviter \field{sender}.
Participants of the conversation, and invitations by inviters other than \field{sender}, are not affected.

\subsubsection{JOIN}

The \message{JOIN} (= 0x19) message is sent by an authenticated invitee to upgrade their own status to a participant of the conversation.
This triggers the creation of a new key exchange process.

TODO how to render this?

\begin{conversationmessage}{JOIN}{0x19}
\end{conversationmessage}

\subsubsection{LEAVE}

TODO how to render this?

\subsubsection{CONSISTENCY\_STATUS}

TODO how to render this?

\subsubsection{CONSISTENCY\_CHECK}

\begin{conversationmessage}{CONSISTENCY\_CHECK}{0x23}
\messagefield{conversation-status-hash}{hash}
\end{conversationmessage}

\subsubsection{TIMEOUT}

\begin{conversationmessage}{TIMEOUT}{0x24}
\messagefield{username}{string}
\messagefield{set-timeout}{boolean}
\end{conversationmessage}

\subsubsection{KEY\_EXCHANGE\_PUBLIC\_KEY}

\begin{conversationmessage}{KEY\_EXCHANGE\_PUBLIC\_KEY}{0x31}
\messagefield{key-id}{hash}
\messagefield{session-public-key}{publickey}
\end{conversationmessage}

\subsubsection{KEY\_EXCHANGE\_SECRET\_SHARE}

\begin{conversationmessage}{KEY\_EXCHANGE\_SECRET\_SHARE}{0x32}
\messagefield{key-id}{hash}
\messagefield{group-hash}{hash}
\messagefield{secret-share}{secretshare}
\end{conversationmessage}

\subsubsection{KEY\_EXCHANGE\_ACCEPTANCE}

\begin{conversationmessage}{KEY\_EXCHANGE\_ACCEPTANCE}{0x33}
\messagefield{key-id}{hash}
\messagefield{key-hash}{hash}
\end{conversationmessage}

\subsubsection{KEY\_EXCHANGE\_REVEAL}

\begin{conversationmessage}{KEY\_EXCHANGE\_REVEAL}{0x34}
\messagefield{key-id}{hash}
\messagefield{session-private-key}{privatekey}
\end{conversationmessage}

\subsubsection{KEY\_ACTIVATION}

\begin{conversationmessage}{KEY\_ACTIVATION}{0x41}
\messagefield{key-id}{hash}
\end{conversationmessage}

\subsubsection{KEY\_RATCHET}

\begin{conversationmessage}{KEY\_RATCHET}{0x42}
\messagefield{key-id}{hash}
\end{conversationmessage}

\subsubsection{CHAT}




\section{Events}
maybe roll this section into the conversation state machine section?

list of events here. Individual events are introduced in the messages section; this section has an overview, and details of what's in each event.


\bibliographystyle{abbrv}
\bibliography{bibliography}


\end{document}
