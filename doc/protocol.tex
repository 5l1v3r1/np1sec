\documentclass{article}

\usepackage{enumitem}
\usepackage{url}

\title{(n+1)sec protocol specification}
\author{eQualit.ie}

\setlength{\parskip}{1em}
\setlength{\parindent}{0em}

\def\message#1{\texttt{#1}}
\def\field#1{\textit{#1}}

\def\smfield#1{\textsf{#1}}

\def\concat{\mathbin{+\!\!\!+\,}}
\def\xor{\oplus}


\newenvironment{basicmessage}[2]{
\newcommand{\messagefield}[2]{
\field{##1} & \textsf{##2} \\
\hline
}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{\message{#1} [#2]} \\
\hline
\hline
}{
\end{tabular}
}

\newenvironment{conversationmessage}[2]{
\newcommand{\messagefield}[2]{
& \field{##1} & \textsf{##2} \\
\hline
}
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{\message{#1} [#2]} \\
\hline
\hline
\field{conversation-public-key} & \multicolumn{2}{l|}{\textsf{publickey}} \\
\hline
\field{conversation-signature} & \multicolumn{2}{l|}{\textsf{signature}} \\
\hline
\field{conversation-message-body} & \multicolumn{2}{l|}{} \\
\hline
}{
\end{tabular}
}






\begin{document}

\maketitle

\section{Introduction}
\label{sec:introduction}

The (n+1)sec system is a protocol for end-to-end encrypted and authenticated textual group chat communications.
It aims to provide a platform and paradigm for synchronous text chat similar to those used in commonly used chat systems such as IRC \cite{irc} and Jabber multi user conversations \cite{jabber}, augmented with the cryptographic tools to guarantee communication security without relying on any third parties for these security assurances.

The (n+1)sec system, in conscious imitation of the celebrated off-the-record or \emph{OTR} chat cryptography framework \cite{otr}, 
% layered on top of a chat network

% this is a protocol spec

% status: draft

% reference implementation

% sections: 2, 3, other



\section{Protocol Overview}
\label{sec:protocol-overview}

The (n+1)sec system is a protocol through which users of text chat systems, such as IRC \cite{irc} or Jabber multi-user-chat \cite{jabber}, can hold cryptographically secured multi-party text chat sessions.
Using an approach similar to OTR \cite{otr}, (n+1)sec clients exchange encoded text messages via a general-purpose group chat room, such as an IRC channel or a Jabber multi-user chat room, and thereby construct end-to-end encrypted chat sessions that use the general-purpose chat room as a carrier.

Chat sessions in (n+1)sec make use of end-to-end encryption to ensure the security of chat communications, even when the chat session is held in a public or otherwise presumed-insecure chat room.
This cryptography is used to authenticate the identity of the members of the chat session, as well as to encrypt the chat communications in such a way that only the members of a chat session have access to the chat contents.

Chat in (n+1)sec takes place in so-called \emph{conversations}.
An (n+1)sec Conversation is a chat session, behaviorally similar to IRC channels and the like, that exists as a distributed agreement between a group of people in a carrier chat room to talk to each other, and whose communication takes place via (n+1)sec messages exchanged in a single carrier chat room.
A Conversation at any point has a set of \emph{participants}, which is part of the state of a Conversation that all participants agree on at any point.
The different Participants in a Conversation have all authenticated each other's identities, as identified by a public key, and ---some caveats notwithstanding--- chat messages in a Conversation are encrypted in such a way that only its constituent Participants can decrypt.

All communications related to a Conversation are necessarily accompanied by a cryptographic signature based on the public key of the sender.
Furthermore, all chat messages in a Conversation ---making up the payload of that Conversation--- are encrypted using a symmetric cryptographic key negotiated between, and known only by, the Conversation's Participants.
This symmetric key is negotiated each time the list of Participants of a Conversation changes (that is, each time a Participant either joins or leaves the Conversation), as well as at regular intervals to reduce the risk of any particular key being compromised.

\subsection{Rooms}
The (n+1)sec protocol makes use of 

Section~\ref{sec:carrier-chatrooms}

% the np1sec protocol uses chatrooms as a transport infrastructure.
% by exchanging np1sec messages in a given chatroom of some description, np1sec clients can engage in encrypted communications with other np1sec clients in that same room.
% within certain limitations, np1sec can work on top of arbitrary text chat systems; the details are in Section~\ref{sec:carrier-chatrooms}.

% when entering a room, an np1sec client sends a message announcing their presence as an np1sec-capabel client.
% as part of this announcement, the client announces a public key, and requests other np1sec clients in the room to identify themselves.
% when this happens, the new signup and the old client engage in a mutual authentication protocol, after which they are (hopefully) both assured of each other's identity.







% np1sec sends messages to rooms. some messages deal with the presence of a user in a room; others are directed at specific conversations and contain metadata about the conversations they apply to.

\subsection{Conversations}
This includes the description of how ephemeral public keys are used to identify conversation participants.


\subsection{Conversation state machine}
on a protocol level, np1sec conversations are represented by state machines represented identically across all clients that take part in the conversation. The np1sec protocol specifies in detail how messages and chat events are to affect this idealized state machine, which implementations need to follow to the letter to stay compatible.


\subsection{Joining a conversation}


\subsection{Events}
Merge into state machine?


\subsection{Key agreement}


\subsection{Chat messages}








\section{Chat Model}
\label{sec:chat-model}

maybe we can skip this?



%what np1sec does
%how np1sec works from an API / UI point of view

% conversation in een carrier room
% participants, invitees, people who can be invited
% authentication, public keys
% messages, event ordering
% votekicks, conversation title?
% cryptographic assurances



\section{Cryptography}
\label{sec:cryptography}

The (n+1)sec protocol makes use of several different cryptographic techniques to implement the security properties outlined in the previous section.
In addition to standard cryptographic constructions such as symmetric ciphers and public-key signatures, (n+1)sec uses versions of the \emph{Triple Diffie-Hellman} deniable authentication scheme, and the 

% TODO finish

\subsection{Triple Diffie-Hellman authenticated key exchange}
\label{sec:cryptography/triple-diffie-hellman}

In several places, the (n+1)sec protocol makes use of the Triple Diffie-Hellman deniable authenticated key exchange protocol \cite{tdh}.
Like the traditional Diffie-Hellman key exchange protocol, the Triple Diffie-Hellman protocol allows two parties to exchange a shared secret over a communication channel on which an eavesdropper may be present, which can be used as the basis of an ephemeral symmetric key which achieves perfect forward secrecy.

Unlike traditional Diffie-Hellman, the Triple Diffie-Hellman protocol provides authentication of the protocol participants, which makes the protocol secure in the face of men in the middle or other active attackers.
This authentication component of the Triple Diffie-Hellman protocol is a form of \emph{deniable} authentication: the messages exchanged in the protocol do not contain any artifacts that an attacker could use as cryptographic proof that communication between two partners occurred, which simpler schemes such as traditional Diffie-Hellman augmented with cryptographic signatures would.

The Triple Diffie-Hellman protocol yields a secret that is known only to the parties holding the private keys of the protocol participants.
By communicating proof that the two parties know this secret, without necessarily using this secret as the base of a symmetric key, the Triple Diffie-Hellman protocol can also be used as a deniable authentication protocol, allowing two parties to authenticate each other under the allowance of deniability.

\subsubsection{Notation}
\label{sec:cryptography/triple-diffie-hellman/notation}

In the remainder of this section, we use $G$ to denote a finite cyclic group of prime order $N$ with generator $g$, and $H$ to denote a cryptographic hash function.
The Triple Diffie-Hellman protocol can be defined in terms of these parameter components, and the description below will use these components abstractly.
The specific algorithms used to implement these cryptographic primitives in the (n+1)sec protocol are described in Section~\ref{sec:cryptography/cryptographic-primitives}.

\subsubsection{Protocol}
\label{sec:cryptography/triple-diffie-hellman/protocol}

The Triple Diffie-Hellman protocol takes place between two parties, denoted Alice and Bob, who each possess a private key and know each other's corresponding public key; these public keys are used as the basis of authentication.
Alice and Bob's private keys take the form of natural numbers $A$ and $B$, respectively, with $1 \leq A, B < N$, where $N$ is the order of the group $G$.
The corresponding public keys are the group values $g^A$ and $g^B$, respectively.

When starting a Triple Diffie-Hellman session, Alice and Bob both generate ephemeral private keys, denoted $a$ and $b$ with $1 \leq a, b < N$, that are used for the duration of the session, and used to derive a shared secret that forms the basis of a symmetric key.
As in traditional Diffie-Hellman, these ephemeral keys are not saved to long-term storage, and erased after the completion of a session, and this forms the basis of forward secrecy: the session secret is based (among others) on these ephemeral keys, which means that compromise of the long-term keys $A$ and $B$ will not jeopardize past session keys.
Alice and Bob announce their respective ephemeral public keys, $g^a$ and $g^b$.

Alice and Bob then compute the terms $g^{Ab}$, $g^{aB}$, and $g^{ab}$.
These terms can be computed by Alice as $g^{Ab} = (g^b)^A$, $g^{aB} = (g^B)^a$, and $g^{ab} = (g^b)^a$, respectively; symmetrically, Bob can compute them as $g^{Ab} = (g^A)^b$, $g^{aB} = (g^a)^B$, and $g^{ab} = (g^a)^b$.
Using these terms as input to a key derivation function, described below, yields a shared secret $S = f(g^{Ab}, g^{aB}, g^{ab})$.

A key property of the Triple Diffie-Hellman protocol is that the key derivation function uses the terms $g^{Ab}$, $g^{aB}$, and $g^{ab}$, but not $g^{AB}$.
Because all terms used by the key derivation function are based on at least one ephemeral key, an attacker who holds both ephemeral private keys -- but neither of the long term private keys -- is also in a position to compute the secret $S$.
Indeed, an attacker knowing $a$, $b$, $g^A$, and $g^B$ can compute $g^{Ab} = (g^A)^b$, $g^{aB} = (g^B)^a$, and $g^{ab}$ = $((g)^a)^b$.

This property has two critical consequences that (n+1)sec relies upon.
A person who knows the public keys of Alice and Bob can generate their own ephemeral private keys $a'$ and $b'$, compute the assorted secret $S$, and thereby forge a convincing exchange between Alice and Bob that is indistinguishable for a third party to a genuine exchange between Alice and Bob.
Because of this forgeability, a genuine exchange between Alice and Bob is useless to a third party as a cryptographic proof of communication between Alice and Bob, which forms the basis of deniable authentication (described below).
Furthermore, the (n+1)sec protocol makes use of the possibility of computing a shared Triple Diffie-Hellman secret based on both ephemeral private keys as part of a denial-of-service recovery procedure, described in Section~\ref{todo:cryptography/key-exchange-reveal}.

\subsubsection{Secret computation}
\label{sec:cryptography/triple-diffie-hellman/secret-computation}

The Triple Diffie-Hellman protocol computes a secret based on the public keys and private keys of the two participants of the protocol.
It does this by computing the terms $g^{Ab}$, $g^{aB}$, and $g^{ab}$, and using these terms as input to a key derivation function.

As described in Section~\ref{sec:cryptography/cryptographic-primitives}, (n+1)sec uses the Ed25519 Twisted Edwards curve \ref{ed25519} as its cryptographic group $G$.
The terms $g^{Ab}$, $g^{aB}$, and $g^{ab}$ are therefore points $(x, y)$ on that curve.
To compute the shared secret $S = f(g^{Ab}, g^{aB}, g^{ab})$, (n+1)sec uses the following procedure:
\begin{enumerate}
\item Compute $g^{Ab}$, $g^{aB}$, $g^{ab}$.
\item For each of $g^{Ab}$, $g^{aB}$, $g^{ab}$, encode the point as a 32-byte stream encoding the $x$-coordinate in little endian encoding.
\item Sort the $x$-coordinate byte streams of the three points in lexicographical order, denoted $x_1$, $x_2$, $x_3$, with $x_1 \leq x_2 \leq x_3$.
\item Compute $S = H(x_1 \concat x_2 \concat x_3)$, where $\concat$ expresses concatenation.
\end{enumerate}
The shared secret $S$ for keys $A$, $a$, $B$, $b$ is also denoted $TDH(g^A, g^a, g^B, g^b)$.

% TODO not implemented like this at the moment

\subsubsection{Authentication}
\label{sec:cryptography/triple-diffie-hellman/authentication}

The Triple Diffie-Hellman protocol exchanges a secret shared by two participants each identified by a pair of public keys.
When one party then sends a message indicating knowledge of the secret, such as a message encrypted using the secret-derived symmetric key or a hash of the secret, this proves to the other party that the sender possesses the private keys on which the secret is based.
Using this scheme, the Triple Diffie-Hellman protocol can be used as a deniable authentication system.

If Alice and Bob exchange a secret $S$, based on Alice's public keys $g^A$ and $g^a$ and Bob's public keys $g^B$ and $g^b$, and Bob then sends a message $m(S)$ derived from $S$ that could not have been derived from any message sent by Alice, this proves to Alice that Bob possesses both the private keys $B$ and $b$.
Bob can then use his ephemeral private key $b$ to generate \emph{deniable signatures} of further messages.
When Alice receives such a message signed using the $b$ private key, she can verify that the message was sent by Bob (for she knows that Bob possesses both $B$ and $b$).
But Alice cannot prove this fact to a third party, for as far as the third party is concerned Alice could possess both $a$ and $b$, and have forged the $b$-based signature as well as $m(S)$.

The (n+1)sec protocol implements this scheme using the following authentication challenge protocol:
\begin{description}[noitemsep]
\item[Participants.] User $A$ with username $U_A$ has announced long term public key $g^A$ and emphemeral public key $g^a$. User $B$ with username $U_B$ has announced $g^B$ and $g^b$.
\item[Round 1.] User $A$ sends user $B$ an \emph{authentication challenge} nonce $N$.
\item[Round 2.] User $B$ sends user $A$ the \emph{authentication confirmation} $T = H(U_B \concat N \concat TDH(g^A, g^a, g^B, g^b))$.
\item[Computation.] User $A$ verifies the correctness of the authentication confirmation. If it is correct, $A$ knows that $B$ possesses the private key $b$.
\end{description}

The (n+1)sec protocol uses the authentication challenge protocol in several places to provide mutual deniable authentication between users, in such a way that authentication of $B$ to $A$ and authentication of $A$ to $B$ typically run in parallel.
This takes the form of a message from a user with username $U_A$, long term public key $g^A$, and ephemeral public key $g^a$, to a user with username $U_B$, long term public key $g^B$, and ephemeral public key $g^b$, containing an authentication challenge $N$; followed by a message from $B$ to $A$ containing the authentication confirmation $T = H(U_B \concat N \concat TDH(g^A, g^a, g^B, g^b))$.
When $A$ receives that message with a correct value of $T$, $A$ can then mark $B$ as being authenticated for the ephemeral public key $g^b$, and accept messages from $B$ signed against that public key.

% TODO T = H(TDH() ++ N ++ U) at the moment, which risks a length extension attack.
% TODO round 1 is skipped sometimes

%\subsubsection{Security properties}
%\label{sec:cryptography/triple-diffie-hellman/security-properties}

% TODO security properties section


\subsection{Group Key Exchange}
\label{sec:cryptography/group-key-exchange}

Chat messages in (n+1)sec sent to a conversation are encrypted using a symmetric key known to all participants of the conversation.
The participants of a conversation negotiate such a key each time a new participant joins the conversation, or a previous participant leaves the conversation.

To exchange such a symmetric key among a group of participants, the (n+1)sec protocol makes use of a \emph{group key exchange} protocol.
A group key protocol is an extension of the traditional Diffie-Hellman key exchange protocol; where the Diffie-Hellman protocol allows two parties to exchange a shared secret over an untrusted communication channel to be used to derive a symmetric key, a group key exchange protocol can achieve the same thing for larger collections of users.
The (n+1)sec protocol invokes an instance of a group key exchange protocol each time a conversation requires a new shared symmetric key.

A complication of group key exchange protocols that has no equivalent in the two-party Diffie-Hellman key exchange protocol lies in the possibility of \emph{denial of service} attacks.
A participant in a group key exchange protocol might send messages containing invalid contribitions to the key exchange, in a way that other participants cannot readily detect, causing the key exchange mechanism to fail.
While most group key exchange protocols will verify at the end that a key was exchanged successfully, and notice the problem if one of the participants to the exchange acted maliciously, most key exchange protocols cannot then determine which participant was responsible for the failure.
Should the participants of the conversation then simply try again to exchange a key, the malicious participant could keep disrupting the negotiation of a key indefinitely, freezing conversation progress without anyone being able to determine the party responsible for this breakdown.

The (n+1)sec protocol makes use of a version of the Abdalla-Chevalier-Manulis-Pointcheval GKE+P authenticated group key exchange \cite{acmp}.
The version of this protocol used by (n+1)sec is modified in such a way that both the participants of a key exchange, and nonparticipating observants of a key exchange, can always determine the party responsible for any failures of the key exchange; these participants can then choose not to include the responsible party in further key exchange attempts, and solve the problem thereby.

\subsubsection{Cryptography}
\label{sec:cryptography/group-key-exchange/cryptography}

The (n+1)sec group key exchange protocol takes place when a group of conversation participants decide that they need a new shared key between themselves.
This happens only when all participants have already authenticated each other, and each participant has a signing key accepted as genuine by all participants.
All communications involved in the group key exchange protocol are signed using the author's such signing key; this aspect of the protocol ensures authentication of all participants involved in a group key exchange procedure.

In this context, the group key exchange protocol has the following conceptual steps:
\begin{enumerate}
\item All participants in the key exchange are ordered in a circle. Participants are denoted $U_0$ to $U_{n-1}$, with indices taken modulo $n$: $U_n = U_0$, $U_{-1} = U_{n-1}$. Participant $U_i$ has public key $k_i = g^{m_i}$.
\item Each participant $U_i$ generates a temporary private key $x_i$, used for the duration of the key exchange, and broadcasts the associated public key $y_i = g^{x_i}$.
\item Each participant $U_i$ computes a Triple Diffie-Hellman secret shared with his left and right neighbours in the circle: $d_{i-1, i} = TDH(k_{i-1}, y_{i-1}, k_i, y_i)$; $d_{i, i+1} = TDH(k_i, y_i, k_{i+1}, y_{i+1})$.
\item Each participant $U_i$ computes and broadcasts the XOR sum of their two Triple Diffie-Hellman secrets: $z_i = d_{i-1, i} \xor d_{i, i+1}$.
\item By combining the linear combinations $z$ of the secrets $d$, each participant computes the secrets $d_{j, j+1}$ for all $0 \leq j < n$. Each participant $U_i$ computes these values by computing $d_{i+1, i+2} := z_{i+1} \xor d_{i, i+1}$, $d_{i+2, i+3} := z_{i+2} \xor d_{i+1, i+2}$, \ldots
\item Each participant $U_i$ computes the shared secret $S = d_{0, 1} \concat d_{1, 2} \concat \ldots \concat d_{n-2, n-1} \concat d_{n-1, 0}$. This secret is used as input to a key derivation function.
\end{enumerate}

This protocol derives its security from the fact that the Triple Diffie-Hellman secrets $d_{j, j+1}$ can be recovered by the participants of the exchange, but not by any eavesdropper.
The different values of $z_j$ form a system of linear equations in the variables $d_{j, j+1}$; the protocol publishes the information that $d_{0, 1} \xor d_{1, 2} = z_{1}$, $d_{1, 2} \xor d_{2, 3} = z_2$, and so on.
Of these $n$ equations, $n - 1$ are independent; the last one can be derived from the first $n - 1$, for $z_0 = d_{n-1, 0} \xor d_{0, 1} = \bigoplus_{i=1, n-1} z_i$.
This makes the values of $z$ a system of $n - 1$ independent linear equations in $n$ variables, which provides no usable information to an eavesdropper.
Only by knowing the value of at least one secret $d$ are participants able to compute the values of all other secrets $d_{j, j+1}$, for this gives the equation system a unique solution.

When the cryptographic protocol above is finished, the participants confirm to each other that they have all computed the same value of $S$.
If this is not the case, this indicates that at least one of the participants $U_i$ is malicious, and has broadcast a value of $z_i$ that is not derived correctly from the public key $y_i$ they announced.
In this situation, the participants of the protocol can all reveal their private key $x_i$; this allows all participants (and nonparticipating observers) to compute the correct values $y_j$ and $z_j$ that all participants should have announced.
By comparing these expected values to the values actually broadcast, participants and observers can identify the malicious participant, and start a new group key exchange without that participant.

\subsubsection{Protocol}
\label{sec:cryptography/group-key-exchange/protocol}

The (n+1)sec protocol implements a concrete version of the abstract protocol described in the previous section.
This protocol gets invoked when the set of chat-eligible members of a conversation changes, for reasons such as members joining and leaving the conversation.
It also gets invoked when an existing group key has been in use for some time; by replacing a group key after a finite time limit, this limits the risk of the compromise of a symmetric group key, and thereby ensures that the compromise of any short-term keys compromises only a small fragment of long-running conversations.
The details of the invocation of the group key exchange protocol are described from Section~\ref{sec:conversation-state-machine} onwards.

The group key exchange protocol implemented by (n+1)sec consists of a maximum of four phases.
After completing the two cryptographic phases described in Section~\ref{sec:cryptography/group-key-exchange/cryptography}, a third phase takes place in which the participants of the exchange verify that they have all computed the same shared secret.
If this is indeed the case, the exchange finishes with a successful completion.
If not, a fourth phase starts in which all participants reveal their temporary private keys, facilitating denial-of-service recovery.

Concretely, (n+1)sec implements the following protocol:
\begin{description}[noitemsep]
\item[Participants.] The protocol initiates for a set of participants $v$, each having a username $U_v$ and a long term public key $k_v$ known by all participants. Participants are sorted in lexicographical order by username, and denoted $U_0$ to $U_{n-1}$.
\item[Round 1.] Each participant $U_i$ generates a random private key $x_i$ and public key $y_i = g^{x_i}$, and broadcasts $y_i$.
\item[Round 2.] Each participant $U_i$ proceeds as follows:
	\begin{itemize}[noitemsep,nolistsep]\renewcommand{\labelitemi}{--}
	\item compute $\texttt{groupid} := H(U_0 \concat k_0 \concat y_0 \concat \ldots \concat U_{n-1} \concat k_{n-1} \concat y_{n-1})$;
	\item compute $d_{i-1, i} = H(TDH(k_{i-1}, y_{i-1}, k_i, y_i) \concat \texttt{groupid})$ and $d_{i, i+1} = H(TDH(k_i, y_i, k_{i+1}, y_{i+1}) \concat \texttt{groupid})$;
	\item compute $z_i = d_{i-1, i} \xor d_{i, i+1}$;
	\item broadcast $(z_i, \texttt{groupid})$.
	\end{itemize}
\item[Round 3.] Each participant $U_i$ proceeds as follows:
	\begin{itemize}[noitemsep,nolistsep]\renewcommand{\labelitemi}{--}
	\item verify that all participants have sent the correct \texttt{groupid}. If not, abort, and mark all participants that sent an invalid \texttt{groupid} as malicious;
	\item compute $d_{j, j+1}$ for all $0 \leq j < n$, by computing $d_{j, j+1} := z_j \xor d_{j-1, j}$;
	\item compute $S := H(d_{0, 1} \concat d_{1, 2} \concat \ldots \concat d_{n-2, n-1} \concat d_{n-1, 0})$;
	\item broadcast $H(S \concat \texttt{groupid})$.
	\end{itemize}
\item[Round 4.] Each participant $U_i$ proceeds as follows:
	\begin{itemize}[noitemsep,nolistsep]\renewcommand{\labelitemi}{--}
	\item verify that all participants have sent the correct $H(S \concat \texttt{groupid})$. If so, accept $S$ as the exchanged key, and finish.
	\item if not, broadcast the private key $x_i$.
	\end{itemize}
\item[Aftermath.] If participants disagreed on the value of $H(S \concat \texttt{groupid})$, and the private keys $x_j$ were broadcast, each participant computes the correct values of $y_j$, $z_j$, and $H(S \concat \texttt{groupid})$ for each participant; marks all participants that broadcast invalid values as malicious; and aborts.
\end{description}

When this protocol completes, the participants have either accepted a group key, or have aborted having marked a nonempty set of participants as malicious.
Participants can then start exchanging messages encrypted using this group key; or, in the case of unsuccessful abortion, can remove the malicious participants from the conversation and start a new invocation of the group key exchange protocol for the reduced set of participants.
The details of this response are described in Sections~\ref{sec:conversation-state-machine} and~\ref{sec:messages}.

% TODO security properties



\subsection{Cryptographic primitives}
\label{sec:cryptography/cryptographic-primitives}


choice of primitives -- elliptic curves, signatures, sha256, aes-gcm


\section{Carrier Chatrooms}
\label{sec:carrier-chatrooms}
exact carrier chatroom model

carrier limitations (based on high level API)

invitable user list


\section{The Conversation State Machine}
\label{sec:conversation-state-machine}

%=== introduction to the state machine model ===
%why do we use a state machine model?
%upsides and downsides

%=== participants ===

%=== state machine hash ===
%NOT: the details of how this hash is computed

%=== events ===

%=== key exchanges ===
%including: latest session id

%=== joining ===
%importing a state machine


Terminology:

member: user whose nickname exists in a the state machine

four stages of membership:

unidentified invitee: member without conversation pubkey

unauthenticated identified invitee: member with conversation pubkey but no authentication flag

authenticated invitee: member with conversation pubkey that has been sponsored by a participant

participant: member who has fully joined, can participate in key negotiations, can invite others



\section{Messages}
\label{sec:messages}
list of messages

describes for each message the semantics of the message; the time it may/must be sent; and in a declarative css-style way, the effect of a conversation packet on the conversation state machine

conversation hash computation

rules on what packets apply to what conversations?

\subsection{Message structure}

opcode / sender / payload struct

\subsection{Encoding}

tons of icky details here

\subsection{Room messages}

Room messages are (n+1)sec messages that do not address any particular conversations.
They are used to announce a client as being (n+1)sec capable; to announce a client's cryptographic identity in the form of a public key; and for different (n+1)sec clients in a room to confirm each other's identities.

\subsubsection{QUIT}
\label{sec:messages/quit}

The \message{QUIT} (= 0x01) message causes the sender to effectively leave the room as far as the (n+1)sec protocol is concerned.
A user that sent a \message{QUIT} message is considered in the same state as a user who has not announced (n+1)sec capability; the user has thus left the room from the point of view of the (n+1)sec abstraction, even if the user has not left the carrier chat room.

\begin{basicmessage}{QUIT}{0x01}
\messagefield{cookie}{nonce}
\end{basicmessage}

A \message{QUIT} message declares the \field{sender} to have effectively left the (n+1)sec room.
An implementation should handle it in the same way as the user leaving the carrier chat room.

When receiving a \message{QUIT} message, the client SHOULD retract all cryptographic identities of the \field{sender}, the same way it would do if the \field{sender} were to leave the carrier chat room instead.
The client MUST remove the \field{sender} from all conversations of which they are a member, the same way as if the \field{sender} had left the carrier chat room instead, as described in Section~\ref{todo:conversation-state-machine/left-room}.

The \field{cookie} field carries no significance for clients receiving a \message{QUIT} message and should be ignored.
The field is included to allow an implementation to recognize when it receives its own \message{QUIT} message, and thus leave the (n+1)sec room in a predictable state when connecting to a carrier chat room in which they are already present.


\subsubsection{HELLO}
\label{sec:messages/hello}

The \message{HELLO} (= 0x02) message announces the sender's (n+1)sec capability, as well as their cryptographic identity.
It is sent either by a client when it enters a room to announce its presence to other (n+1)sec users in the room, or in reply to such a message by existing users in the room to announce their presence to the newcomer.

\begin{basicmessage}{HELLO}{0x02}
\messagefield{long-term-public-key}{publickey}
\messagefield{room-public-key}{publickey}
\messagefield{solicit-replies}{boolean}
\end{basicmessage}

A \message{HELLO} message sent to a room by a user \field{sender} indicates that \field{sender} is an (n+1)sec-capable chat client, claiming to possess the private key corresponding to \field{long-term-public-key}.
Based on this declaration, the user receiving the \message{HELLO} message is able to invite the \field{sender} to any current and future conversations, using the announced \field{long-term-public-key}.

A \message{HELLO} message sent by a particular user only indicates that this user \emph{claims} to possess the private key corresponding to the \field{long-term-public-key}.
A client can confirm this cryptographic identity by performing an authentication process, as described in Section~\ref{todo:cryptography/authentication}, using the \field{room-public-key} as the \field{sender}'s ephemeral public key for authentication purposes.
This authentication process is implemented using the \message{ROOM\_AUTHENTICATION\_REQUEST} and \message{ROOM\_AUTHENTICATION} messages.
A client SHOULD NOT trust the authenticity of the \field{sender}'s identity without having successfully completed such an authentication process, and ---from a user interface perspective--- should probably avoid depicting the \field{sender} to hold \field{long-term-public-key} in any way until the authentication process is successfully completed.

To avoid attacks in which a malicious user could waste unlimited resources by sending a large amount of \message{HELLO} messages claiming different identities, an implementation MAY limit the amount of active invitable identities for a particular \field{sender} to 1, or limit it based on some other characteristic.
If so, a \message{HELLO} message claiming an identity the implementation does not currently consider active MAY be interpreted by the implementation as an implicit retraction of any earlier claimed identities by this \field{sender}.
If an implementation does interpret a \message{HELLO} message as a retraction of earlier identities in this way, it may only retract these identities for the sake of representing the visible users in the room, as described in Section~\ref{sec:carrier-chatrooms}.
In particular, the \message{HELLO} message MUST NOT have any effect on any conversations of which the \field{sender} is a member.

The \field{solicit-replies} flag, if set, indicates that the sender requests all (n+1)sec-capable clients in the room to identify itself; this is generally the case after a user has just joined a room, and wants to be able to invite the people in it to conversations.
If this flag is set, any clients that wish to identify themselves can reply with a \message{HELLO} message of their own, repeating their already-established identity to the new user.
However, to avoid bandwidth amplification attacks, implementations SHOULD avoid replying to a message with \field{solicit-replies} set from a \field{sender} to which it has already identified itself.
To avoid infinite sequences of \message{HELLO} replies, a reply message to a message with \field{solicit-replies} set MUST NOT itself have \field{solicit-replies} set.


\subsubsection{ROOM\_AUTHENTICATION\_REQUEST}
\label{sec:messages/room-authentication-request}

The \message{ROOM\_AUTHENTICATION\_REQUEST} (= 0x03) message is used to request a client to authenticate itself based on the cryptographic identity announced in an earlier \message{HELLO} message.
It contains the authentication challenge that forms the base of this authentication process.

\begin{basicmessage}{ROOM\_AUTHENTICATION\_REQUEST}{0x03}
\messagefield{my-long-term-public-key}{publickey}
\messagefield{my-room-public-key}{publickey}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\messagefield{room-public-key}{publickey}
\messagefield{authentication-challenge}{nonce}
\end{basicmessage}

A \message{ROOM\_AUTHENTICATION\_REQUEST} message is a request to the client that uses the identity consisting of the (\field{username}, \field{long-term-public-key}, \field{room-public-key}) triple to authenticate itself to the user using the (\field{sender}, \field{my-long-term-public-key}, \field{my-room-public-key}) identity.
It declares that \field{sender} will consider \field{username} authenticated for this identity after receiving a valid authentication confirmation for this pair of identities, described in Section~\ref{todo:cryptography/authentication}, using \field{authentication-challenge} as the authentication challenge.

A \message{ROOM\_AUTHENTICATION\_REQUEST} message is addressed to the user with username \field{username} and private keys matching the \field{long-term-public-key} and \field{room-public-key}.
Any client that does not have this complete identity ---including clients that use this username but use different keys--- SHOULD ignore the message.
The client that does have this identity, if any, can authenticate itself to the \field{sender} by sending a \message{ROOM\_AUTHENTICATION} message containing the authentication confirmation described above.


\subsubsection{ROOM\_AUTHENTICATION}
\label{sec:messages/room-authentication}

The \message{ROOM\_AUTHENTICATION} (= 0x04) message provides confirmation of a cryptographic identity to a single recipient.
Assuming the authentication confirmation is valid, this allows the recipient to confirm that the sender holds the private keys they claimed to possess in a \message{HELLO} message.

\begin{basicmessage}{ROOM\_AUTHENTICATION}{0x04}
\messagefield{my-long-term-public-key}{publickey}
\messagefield{my-room-public-key}{publickey}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\messagefield{room-public-key}{publickey}
\messagefield{authentication-confirmation}{authentication-token}
\end{basicmessage}

A \message{ROOM\_AUTHENTICATION} message is a confirmation to the client using the identity consisting of the (\field{username}, \field{long-term-public-key}, \field{room-public-key}) triple that the \field{sender} holds the private keys corresponding to \field{my-long-term-public-key} and \field{my-room-public-key}.
The \emph{authentication-confirmation} should contain the authentication token described in Section~\ref{todo:cryptography/authentication}; if it does, this proves that the sender does indeed hold these private keys.

A \message{ROOM\_AUTHENTICATION} message is addressed to the user with username \field{username} and private keys matching the \field{long-term-public-key} and \field{room-public-key}.
Any client that does not have this complete identity ---including clients that use this username but use different keys--- SHOULD ignore the message.
The client that does have this identity, if any, should consider the authentication valid if and only if
\begin{itemize}
\item that client previously sent a \message{ROOM\_AUTHENTICATION\_REQUEST} to the user with identity (\field{username}, \field{long-term-public-key}, \field{room-public-key}), and
\item the \field{authentication-confirmation} field equals the expected authentication token computed from the \field{authentication-challenge} sent in the accompanying \message{ROOM\_AUTHENTICATION\_REQUEST} message, as specified in Section~\ref{todo:cryptography/authentication}.
\end{itemize}
If both requirements hold, this proves that the \field{sender} holds the private key corresponding to \field{my-long-term-public-key}.


\subsection{Conversation messages}
\label{sec:messages/conversation-messages}

The majority of messages in (n+1)sec are addressed to, and relevant for, a particular conversation.
These \emph{conversation messages} contain information addressing the recipient conversation, and affect only the status of that specific conversation.
Conversation messages have a shared structure expressing the relation between messages and conversations, and are handled in a similar way.

\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{Conversation message general structure} \\
\hline
\hline
\field{conversation-public-key} & \textsf{publickey} \\
\hline
\field{message-signature} & \textsf{signature} \\
\hline
\field{message-body} & \textsf{octet-stream} \\
\hline
\end{tabular}

Conversation messages are sent by the identified members of a particular conversation, and addressed to all members of that conversation.
To denote the conversation to which a conversation message is addressed, conversation messages carry a \field{conversation-public-key} field, which contains the conversation public key of the identified conversation member that sent the message.
The conversation addressed by a conversation message, then, is that conversation (if any) that contains an identified member with username \field{sender} and conversation public key \field{conversation-public-key}.
Conversation messages also carry a \field{message-signature}, which is a signature of the message-specific body of the message signed using the private key corresponding to \field{conversation-public-key}.

The members of a conversation, as described in Section~\ref{todo:conversation-state-machine}, share a representation of the abstract \emph{conversation state machine} that defines the state of the conversation.
Coordination between members of a conversation relies on the different members maintaining consensus about the exact state of this state machine; if members of a conversation somehow come to disagree about the state of this state machine, the conversation can no longer be maintained, as described in Section~\ref{todo:conversation-state-machine/inconsistency}.
It is therefore critical that different members of a conversation process conversation messages in such a way that the abstract conversation state machine is affected in precisely identical ways between their clients.

This section specifies for each conversation message what effect the message has on the abstract conversation state machine of each conversation to which it applies.
In order to not break compatibility, implementation MUST implement these specifications to the letter.
Some aspects of a client's state for a particular conversation, such as the determination of which other members are authenticated, are not contained in the conversation state machine; for those topics, the specification has a force limited to a behavior that the client SHOULD implement.

Conversation messages contain a signature of the message body, which is used to verify authenticity of messages sent by conversation members.
This signature is computed as a cryptographic signature of the message's \field{message-body} octet stream, as described in Section~\ref{todo:cryptography/signatures}, using the private key corresponding to the message's \field{conversation-public-key}.
On receiving any converstaion message, clients should verify this signature, by confirming that the message's \field{message-signature} is a valid signature of the message's \field{message-body} for the \field{conversation-public-key}.
If this signature is not valid, implementations MUST NOT modify the conversation state machine of any conversations.
Implementations SHOULD ignore messages with invalid signatures entirely, though they MAY raise some form of impersonation warning instead.

If a conversation message has a valid signature matching its \field{conversation-public-key}, the message is addressed to any conversations, existing in the carrier chat room in which the message was sent, that contain an identified member with username \field{sender} and conversation public key \field{conversation-public-key}.
Conversations matching these conditions are said to be \emph{addressed by} the conversation message.
On receiving a conversation message with a valid signature, implementations MUST NOT modify the conversation state machine of any conversations that are not addressed by the message.
Implementations MUST modify the conversation state machine of any conversations addressed by the message for which the implementation is maintaining a representation, by implementing the rules specified below.

There is one exception that applies to this specification of conversations addressed by conversation messages.
The \message{INVITE\_ACCEPTANCE} message, described in Section~\ref{sec:messages/invite-acceptance}, is used by unidentified members of a conversation to upgrade their status to an identified member, and is addressed to and processed by certain conversations beyond those that include the \field{sender} as an identified member.
These \message{INVITE\_ACCEPTANCE} messages carry a \field{message-signature} signed based on its \field{conversation-public-key} as normal, but are addressed to a larger collection of conversations.
The details of this anomaly are specified in Section~\ref{sec:messages/invite-acceptance}.

When an implementation receives a conversation message with a valid signature addressed to one or more conversations of which the implementation is maintaining a representation, the implementation must digest the message into those conversations' \smfield{status hash}, as described in Section~\ref{todo:conversation-state-machine/hash}.
For each of those conversations to which the message is addressed, the implementation must then perform the message-specific processing specified in the remainder of this section.

\subsubsection{Event messages}

\subsubsection{INVITE}

The \message{INVITE} (= 0x11) message is sent by a conversation participant to invite a new user to the conversation, identified by a (username, long term public key) pair.
An \message{INVITE} message informs the invited user of the existence of the conversation, and allows the invited user to start tracking the status of the conversation.

\begin{conversationmessage}{INVITE}{0x11}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\end{conversationmessage}

An \message{INVITE} message 


\subsubsection{CONVERSATION\_STATUS}

\begin{conversationmessage}{CONVERSATION\_STATUS}{0x12}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\messagefield{conversation-state-machine}{state-machine}
\end{conversationmessage}

\subsubsection{CONVERSATION\_CONFIRMATION}

\begin{conversationmessage}{CONVERSATION\_CONFIRMATION}{0x13}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\messagefield{conversation-status-hash}{hash}
\end{conversationmessage}

\subsubsection{INVITE\_ACCEPTANCE}
\label{sec:messages/invite-acceptance}

\begin{conversationmessage}{INVITE\_ACCEPTANCE}{0x14}
\messagefield{my-long-term-public-key}{publickey}
\messagefield{inviter-username}{string}
\messagefield{inviter-long-term-public-key}{publickey}
\messagefield{inviter-conversation-public-key}{publickey}
\end{conversationmessage}

Addressed-conversation exception documentation here.

\subsubsection{CONVERSATION\_AUTHENTICATION\_REQUEST}

The \message{CONVERSATION\_AUTHENTICATION\_REQUEST} (= 0x15) message is used to request a conversation member to authenticate itself for the cryptographic identity consisting of its long term public key and conversation public key.
It is the in-conversation analogue of the \message{ROOM\_AUTHENTICATION\_REQUEST} message.
It contains the authentication challenge that forms the base of this authentication process.

\begin{conversationmessage}{CONVERSATION\_AUTHENTICATION\_REQUEST}{0x15}
\messagefield{username}{string}
\messagefield{authentication-challenge}{nonce}
\end{conversationmessage}

A \message{CONVERSATION\_AUTHENTICATION\_REQUEST} message is a request to the identified member \field{username} to authenticate itself to the \field{sender}, for \field{username}'s and \field{sender}'s long term public keys and conversation public keys described by the conversation state machine.
It declares that \field{sender} will consider \field{username} authenticated for this identity after receiving a valid authentication confirmation for this pair of identities, described in Section~\ref{todo:cryptography/authentication}, using \field{authentication-challenge} as the authentication challenge.
The \field{username} identified member, upon receiving a \message{CONVERSATION\_AUTHENTICATION\_REQUEST} message, can authenticate itself to the \field{sender} by sending a \message{CONVERSATION\_AUTHENTICATION} message containing this authentication confirmation.

The \message{CONVERSATION\_AUTHENTICATION\_REQUEST} message has no effect on the conversation state machine besides the \smfield{status hash}.

\subsubsection{CONVERSATION\_AUTHENTICATION}

The \message{CONVERSATION\_AUTHENTICATION} (= 0x16) message provides confirmation of a cryptographic identity to a member of a conversation.
It is the in-conversation analogue of the \message{ROOM\_AUTHENTICATION} message.
Assuming the authentication confirmation is valid, this allows the recipient member to confirm that the sender holds the private keys corresponding to their public keys described by the conversation state machine.

\begin{conversationmessage}{CONVERSATION\_AUTHENTICATION}{0x16}
\messagefield{username}{string}
\messagefield{authentication-confirmation}{authentication-token}
\end{conversationmessage}

TODO: This, and the above message, probably needs to be formalized.






\subsubsection{AUTHENTICATE\_INVITE}

The \message{AUTHENTICATE\_INVITE} (= 0x17) message is sent by a conversation participant to promote an identified, unauthenticated invitee to an authenticated invitee.
Afterwards, the authenticated invitee is able to join the conversation as a participant.

\begin{conversationmessage}{AUTHENTICATE\_INVITE}{0x17}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\messagefield{conversation-public-key}{publickey}
\end{conversationmessage}

An \message{AUTHENTICATE\_INVITE} message indicates that the \field{sender} has confirmed that the member \field{username} holds the identity consisting of the (\field{username}, \field{long-term-public-key}, \field{conversation-public-key}) triple, and that \field{sender} is willing to allow this user entrance into the conversation.
Once this allowance has been granted, the invited member is able to join the conversation with a \message{JOIN} message.

If a conversation contains an unauthenticated identified invitee invited by a certain participant, that participant SHOULD send an \message{AUTHENTICATE\_INVITE} message after receiving a \message{CONVERSATION\_AUTHENTICATION} message that successfully confirms the identity of the invitee.
Any other participants may also send such an \message{AUTHENTICATE\_INVITE} message, and thereby become the inviter of the invited member.

If the conversation state machine addressed by an \message{AUTHENTICATE\_INVITE} message contains an unauthenticated identified member with identity triple (\field{username}, \field{long-term-public-key}, \field{conversation-public-key}), and the \field{sender} is a participant of the conversation, then the unauthenticated member gets promoted to an authenticated member.
The newly-authenticated member's inviter becomes the message's \field{sender}.
If not, the \message{AUTHENTICATE\_INVITE} message has no effect on the conversation state machine besides the \smfield{status hash}.

\subsubsection{CANCEL\_INVITE}

The \message{CANCEL\_INVITE} (= 0x18) message is sent by a conversation participant to retract any invitations for a given (username, long term public key) pair.

\begin{conversationmessage}{CANCEL\_INVITE}{0x18}
\messagefield{username}{string}
\messagefield{long-term-public-key}{publickey}
\end{conversationmessage}

A \message{CANCEL\_INVITE} message indicates that the \field{sender} wants to retract an active invitation for a given user.
If no active invitations for the described member exist, or the member described by the \message{CANCEL\_INVITE} message has since become a participant of the conversation, the message has no effect.

A \message{CANCEL\_INVITE} message removes from the conversation state machine any invited members ---be they unidentified invitees, unauthenticated identified invitees, or authenticated invitees--- with username \field{username}, long term public key \field{long-term-public-key}, and inviter \field{sender}.
Participants of the conversation, and invitations by inviters other than \field{sender}, are not affected.

\subsubsection{JOIN}

The \message{JOIN} (= 0x19) message is sent by an authenticated invitee to upgrade their own status to a participant of the conversation.
This triggers the creation of a new key exchange process.

TODO how to render this?

\begin{conversationmessage}{JOIN}{0x19}
\end{conversationmessage}

\subsubsection{LEAVE}

TODO how to render this?

\subsubsection{CONSISTENCY\_STATUS}

TODO how to render this?

\subsubsection{CONSISTENCY\_CHECK}

\begin{conversationmessage}{CONSISTENCY\_CHECK}{0x23}
\messagefield{conversation-status-hash}{hash}
\end{conversationmessage}

\subsubsection{TIMEOUT}

\begin{conversationmessage}{TIMEOUT}{0x24}
\messagefield{username}{string}
\messagefield{set-timeout}{boolean}
\end{conversationmessage}

\subsubsection{KEY\_EXCHANGE\_PUBLIC\_KEY}

\begin{conversationmessage}{KEY\_EXCHANGE\_PUBLIC\_KEY}{0x31}
\messagefield{key-id}{hash}
\messagefield{session-public-key}{publickey}
\end{conversationmessage}

\subsubsection{KEY\_EXCHANGE\_SECRET\_SHARE}

\begin{conversationmessage}{KEY\_EXCHANGE\_SECRET\_SHARE}{0x32}
\messagefield{key-id}{hash}
\messagefield{group-hash}{hash}
\messagefield{secret-share}{secretshare}
\end{conversationmessage}

\subsubsection{KEY\_EXCHANGE\_ACCEPTANCE}

\begin{conversationmessage}{KEY\_EXCHANGE\_ACCEPTANCE}{0x33}
\messagefield{key-id}{hash}
\messagefield{key-hash}{hash}
\end{conversationmessage}

\subsubsection{KEY\_EXCHANGE\_REVEAL}

\begin{conversationmessage}{KEY\_EXCHANGE\_REVEAL}{0x34}
\messagefield{key-id}{hash}
\messagefield{session-private-key}{privatekey}
\end{conversationmessage}

\subsubsection{KEY\_ACTIVATION}

\begin{conversationmessage}{KEY\_ACTIVATION}{0x41}
\messagefield{key-id}{hash}
\end{conversationmessage}

\subsubsection{KEY\_RATCHET}

\begin{conversationmessage}{KEY\_RATCHET}{0x42}
\messagefield{key-id}{hash}
\end{conversationmessage}

\subsubsection{CHAT}




\section{Events}
maybe roll this section into the conversation state machine section?

list of events here. Individual events are introduced in the messages section; this section has an overview, and details of what's in each event.


\bibliographystyle{abbrv}
\bibliography{bibliography}


\end{document}
